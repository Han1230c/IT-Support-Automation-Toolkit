#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
IT Support Automation Toolkit — Enhanced CLI
- Batch run modules (system / network / users)
- Structured logging with durations & line counts
- One-page HTML summary
- Supports --clean / --clean-only to purge old outputs
- Passes fast params to network_check.py for quick runs
"""

import argparse, json, os, sys, subprocess, time, csv, datetime
from pathlib import Path

def load_config(path):
    if not path:
        return {}
    p = Path(path)
    if not p.exists():
        raise FileNotFoundError(f"Config file not found: {path}")
    if p.suffix.lower() in (".json", ".cfg"):
        with open(p,"r",encoding="utf-8") as f:
            return json.load(f)
    # Simple key=value fallback
    cfg = {}
    with open(p,"r",encoding="utf-8") as f:
        for line in f:
            line=line.strip()
            if not line or line.startswith("#"):
                continue
            if "=" in line:
                k,v = line.split("=",1)
                cfg[k.strip()] = v.strip()
    return cfg

def ensure_dirs(outdir: Path):
    outdir.mkdir(parents=True, exist_ok=True)
    (outdir.parent / "logs").mkdir(parents=True, exist_ok=True)

def log_line(logfile: Path, level: str, msg: str):
    ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    line = f"{ts} [{level}] {msg}\n"
    with open(logfile, "a", encoding="utf-8") as f:
        f.write(line)
    print(line, end="")

def count_lines(path: Path):
    try:
        with open(path,"r",encoding="utf-8", errors="ignore") as f:
            return sum(1 for _ in f)
    except Exception:
        return None

def run_module(pyfile: Path, args, logfile: Path):
    """Run a subprocess and time it. Return (ok, duration_s, extra)."""
    start = time.time()
    try:
        proc = subprocess.run(
            [sys.executable, str(pyfile), *args],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            cwd=str(pyfile.parent),
            timeout=300
        )
        dur = time.time() - start
        if proc.returncode != 0:
            log_line(logfile, "ERROR",
                     f"{pyfile.name} failed (rc={proc.returncode}) in {dur:.2f}s | stderr: {proc.stderr.strip()[:500]}")
            return False, dur, {"stderr": proc.stderr, "stdout": proc.stdout}
        else:
            log_line(logfile, "INFO", f"{pyfile.name} completed in {dur:.2f}s")
            return True, dur, {"stderr": proc.stderr, "stdout": proc.stdout}
    except subprocess.TimeoutExpired:
        dur = time.time() - start
        log_line(logfile, "ERROR", f"{pyfile.name} timeout after {dur:.2f}s")
        return False, dur, {}

def generate_html(outdir: Path, summary: dict):
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    rows = []
    def r(k,v):
        rows.append(f"<tr><td>{k}</td><td>{v}</td></tr>")
    r("Run Time", now)
    r("System Report", summary.get("system_csv","-"))
    r("Network Report (csv)", summary.get("network_csv","-"))
    r("Network Report (txt)", summary.get("network_txt","-"))
    r("User Audit Summary", summary.get("user_summary","-"))
    r("User Audit Detail", summary.get("user_detail","-"))
    r("Warnings", "<br>".join(summary.get("warnings", [])) or "-")
    if summary.get("durations"):
        r("Durations (s)", "<br>".join(f"{k}: {v:.2f}" for k,v in summary.get("durations",{}).items()))
    if summary.get("lines"):
        r("Line Counts", "<br>".join(f"{k}: {v}" for k,v in summary.get("lines",{}).items()))
    html = f"""<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>IT Support Automation Toolkit — Summary</title>
<style>
 body {{ font-family: -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; }}
 h1 {{ margin-bottom: 0; }}
 .ts {{ color:#666; margin-top: 4px; }}
 table {{ border-collapse: collapse; width: 100%; margin-top: 16px; }}
 td, th {{ border: 1px solid #ddd; padding: 8px; vertical-align: top; }}
 tr:nth-child(even) {{ background: #fafafa; }}
 .small {{ font-size: 12px; color:#777 }}
</style>
</head>
<body>
  <h1>IT Support Automation Toolkit — Summary</h1>
  <div class="ts small">{now}</div>
  <table>
    <tbody>
      {''.join(rows)}
    </tbody>
  </table>
  <p class="small">Auto-generated by toolkit_cli.py</p>
</body>
</html>"""
    ts = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    out_html = outdir / f"summary_{ts}.html"
    with open(out_html, "w", encoding="utf-8") as f:
        f.write(html)
    return out_html

def clean_outputs(outdir: Path, logfile: Path):
    import shutil
    log_line(logfile, "INFO", "Clean mode enabled: removing old reports and logs")
    for folder in [outdir, outdir.parent / "logs"]:
        folder.mkdir(parents=True, exist_ok=True)
        for item in list(folder.iterdir()):
            try:
                if item.is_file():
                    item.unlink()
                elif item.is_dir():
                    shutil.rmtree(item)
            except Exception as e:
                log_line(logfile, "WARN", f"Failed to remove {item}: {e}")

def main():
    parser = argparse.ArgumentParser(description="IT Support Automation Toolkit — Enhanced CLI")
    parser.add_argument("--all", action="store_true", help="Run all checks")
    parser.add_argument("--system", action="store_true", help="Run system health check")
    parser.add_argument("--network", action="store_true", help="Run network connectivity check")
    parser.add_argument("--users", action="store_true", help="Run user account audit")
    parser.add_argument("--target", default=None, help="Target host for network checks")
    parser.add_argument("--config", default=None, help="Config file (.json or key=value lines)")
    parser.add_argument("--out", default="reports", help="Output directory for reports (default: reports)")
    parser.add_argument("--clean", action="store_true", help="Clean old reports/logs before run")
    parser.add_argument("--clean-only", action="store_true", help="Only clean reports/logs and exit")
    args = parser.parse_args()

    cfg = load_config(args.config)
    base = Path(__file__).parent
    outdir = base / args.out if not os.path.isabs(args.out) else Path(args.out)
    ensure_dirs(outdir)

    # per-day log
    log_path = outdir.parent / "logs" / (datetime.datetime.now().strftime("%Y-%m-%d") + ".log")
    log_line(log_path, "INFO", f"Run start | args={vars(args)} | cfg_keys={list(cfg.keys())}")

    # cleaning
    if args.clean or args.clean_only:
        clean_outputs(outdir, log_path)
        if args.clean_only and not (args.all or args.system or args.network or args.users):
            log_line(log_path, "INFO", "Clean-only mode complete. Exiting.")
            sys.exit(0)

    if not (args.all or args.system or args.network or args.users):
        parser.print_help()
        log_line(log_path, "ERROR", "No task selected. Use --all or specific flags.")
        sys.exit(2)

    durations = {}
    lines = {}
    warnings = []
    rc = 0  # overall return code

    # 1) System
    if args.all or args.system:
        ok, dur, extra = run_module(base / "system_health_check.py", [], log_path)
        durations["system"] = dur
        sys_csv = None
        for p in sorted(outdir.glob("system_report_*.csv"), key=lambda p: p.stat().st_mtime, reverse=True):
            sys_csv = p; break
        if sys_csv:
            lines[sys_csv.name] = count_lines(sys_csv)
        else:
            warnings.append("System report not found."); rc = rc or 1

    # 2) Network (fast, pass target/out)
    if args.all or args.network:
        net_args = ["--out", str(outdir), "--fast"]
        if args.target or cfg.get("target"):
            net_args += ["--target", args.target or cfg.get("target")]
        ok, dur, extra = run_module(base / "network_check.py", net_args, log_path)
        durations["network"] = dur
        net_csv = None; net_txt = None
        for p in sorted(outdir.glob("network_report_*.csv"), key=lambda p: p.stat().st_mtime, reverse=True):
            net_csv = p; break
        for p in sorted(outdir.glob("network_report_*.txt"), key=lambda p: p.stat().st_mtime, reverse=True):
            net_txt = p; break
        if net_csv: lines[net_csv.name] = count_lines(net_csv)
        else: warnings.append("Network CSV report not found."); rc = rc or 1
        if net_txt: lines[net_txt.name] = count_lines(net_txt)
        else: warnings.append("Network TXT report not found."); rc = rc or 1

    # 3) Users
    if args.all or args.users:
        ok, dur, extra = run_module(base / "user_account_report.py", [], log_path)
        durations["users"] = dur
        ua_sum = None; ua_det = None
        for p in sorted(outdir.glob("user_audit_summary_*.csv"), key=lambda p: p.stat().st_mtime, reverse=True):
            ua_sum = p; break
        for p in sorted(outdir.glob("user_audit_detail_*.csv"), key=lambda p: p.stat().st_mtime, reverse=True):
            ua_det = p; break
        if ua_sum: lines[ua_sum.name] = count_lines(ua_sum)
        else: warnings.append("User audit SUMMARY report not found."); rc = rc or 1
        if ua_det: lines[ua_det.name] = count_lines(ua_det)
        else: warnings.append("User audit DETAIL report not found."); rc = rc or 1

    # Summary
    def latest_name(dirpath: Path, pat: str):
        files = sorted(Path(dirpath).glob(pat), key=lambda p: p.stat().st_mtime, reverse=True)
        return files[0].name if files else None

    summary = {
        "durations": durations,
        "lines": lines,
        "warnings": warnings,
        "system_csv": latest_name(outdir, "system_report_*.csv"),
        "network_csv": latest_name(outdir, "network_report_*.csv"),
        "network_txt": latest_name(outdir, "network_report_*.txt"),
        "user_summary": latest_name(outdir, "user_audit_summary_*.csv"),
        "user_detail": latest_name(outdir, "user_audit_detail_*.csv"),
    }

    out_html = generate_html(outdir, summary)
    log_line(log_path, "INFO", f"Summary HTML generated -> {out_html}")
    if warnings:
        log_line(log_path, "WARN", f"Warnings: {warnings}")
    log_line(log_path, "INFO", "Run end.")
    sys.exit(rc)

if __name__ == "__main__":
    main()
